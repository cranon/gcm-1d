
int NumMethod::ImplicitSecondOrder(Mesh *mesh) {
	int N = mesh->NumX;
	float a[N], b[N], c[N], d[N], e[N], f[N], P[N], Q[N], M[N], L[N], r1[N], r2[N];
	for (int k = 1; k < N; k++) {
		float A = 0.5*(mesh->Values[k].getA() + mesh->Values[k-1].getA());
		float g1 = 0; // fix normal calculating g!
		float g2 = 0; // fix normal calculating g!
		float h = 0.01; //mesh->Values[k].x - mesh->Values[k-1].x; Это пиздец
		a[k] = 1 - A*tau/h;
		b[k] = 1 + A*tau/h;
		c[k] = 2*A*tau*g1 - 2*tau*g2 + a[k]*mesh->Values[k].getInv(1,A) + \
				b[k]*mesh->Values[k-1].getInv(1,A);
		cout <<  c[k] << endl;
	}
	for (int k = 0; k < N-1; k++) {
		float A = 0.5*(mesh->Values[k].getA() + mesh->Values[k+1].getA());
		float g1 = 0; // fix normal calculating g!
		float g2 = 0; // fix normal calculating g!
		float h = 0.01; //mesh->Values[k+1].x - mesh->Values[k].x;
		e[k] = 1 - A*tau/h;
		d[k] = 1 + A*tau/h;
		f[k] = 2*A*tau*g1 + 2*tau*g2 + e[k]*mesh->Values[k].getInv(2,A) + \
				d[k]*mesh->Values[k+1].getInv(2,A);
	}
	P[1] = -b[1]/a[1];
	Q[1] = c[1]/a[1];
	for (int i = 1; i < N-1; i++) {
		P[i+1] = -P[i]*b[i+1]/a[i+1];
		Q[i+1] = Q[i] + P[i]*c[i+1]/a[i+1];
	}
	M[1] = -e[0]/d[0];
	L[1] = f[0]/d[0];
	for (int i = 1; i < N-1; i++) {
		M[i+1] = -M[i]*e[i]/d[i];
		L[i+1] = M[i]*f[i]/d[i] + L[i];
	}
	float eta = 0;	// fix normal choosing eta, ...
	float dzeta = 0;
	float ksi = 1;
	float kapa = 1;
	r1[N-1] = (eta - ksi*Q[N-1] - dzeta*M[N-1] - L[N-1])/(ksi*P[N-1] - kapa*M[N-1]);
	r2[N-1] = dzeta - kapa*r1[N-1];
	for (int k = N-1; k > 0; k--) {
		r1[k-1] = -r1[k]*b[k]/a[k] + c[k]/a[k];
	}
	for (int k = N-2; k >= 0; k--) {
		r2[k] = -r2[k+1]*e[k]/d[k] + f[k]/d[k];
	}
	for (int k = 0; k < N; k++) {
		mesh->Values[k].v = (r1[k] + r2[k])/2/mesh->Values[k].getA(); //fix getA!
		mesh->Values[k].eps = (r2[k] - r1[k])/2;
		// fix x[k]!
	}
	return 0;
 }